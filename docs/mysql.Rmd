---
title: "MySQL Commands"
author: "Paul Rougieux"
date: "25 August 2017"
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
library(dplyr)
library(eutradeflows)
# To compile this document, run the following at an R prompt:
# rmarkdown::render("~/R/eutradeflows/docs/mysql.Rmd")

knitr::opts_chunk$set(echo = TRUE)

con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "tradeflows")
```

# Dump
## Load a dump
The following commands can be used to load mysql dump files:
```{bash eval=FALSE}
7zr e raw_comext_monthly_201708.sql.7z
cat raw_comext_monthly_201708.sql | mysql tradeflows
```


## Create a dump
[how to compress a mysqldump with 7z via a pipe?](https://unix.stackexchange.com/questions/232006/how-to-compress-a-mysql-dump-using-7z-via-a-pipe)
First version needed to make sure the archive doesn't exist already 
other wise it would contain the SQL dump twice.
See Paul's question on stackexchange 
[How to overwrite content in a 7z archive created from a pipe?](https://unix.stackexchange.com/questions/386913/how-to-overwrite-content-in-a-7z-archive-created-from-a-pipe)
The answer is to supply a name for the file generated from standard input, 
within the `-si` option, such as `-sifilename`.
```{bash eval=FALSE}
# prefer 7zr to 7z as this is the only one available on the server
cd _server_path_/sqldump

# Recent data
mysqldump tradeflows raw_comext_monthly_201708 | 7zr a -siraw_comext_monthly_201708.sql raw_comext_monthly_201708.sql.7z
mysqldump tradeflows raw_comext_monthly_201709 | 7zr a -siraw_comext_monthly_201709.sql raw_comext_monthly_201709.sql.7z

# Monthly archive
mysqldump tradeflows raw_comext_monthly_2016S1 | 7zr a -si raw_comext_monthly_2016S1.sql.7z

# Dump validated codes
mysqldump tradeflows vld_comext_product | 7zr a -si vld_comext_product.sql.7z
mysqldump tradeflows vld_comext_reporter | 7zr a -si vld_comext_reporter.sql.7z
mysqldump tradeflows vld_comext_partner | 7zr a -si vld_comext_partner.sql.7z
```

Create an R function that dumps a database table to a given folder location.
If the archive exists already, do not recreate it, unless force=TRUE.
    If force=TRUE, delete the archive.
If the archive doesn't exist, 
compress the output of mysqldump and store it in the given folder.

Create an R function that dumps all tables in the trade flows database, 
each table in a separate .sql.7z file.

Create an R function that dumps all tables containing a given pattern in 
their names, such as "monthly" or "yearly".



# Comparing query time between %like%, == and %in%


## Productcode as a numeric vector %like%
```{r}
productpattern <- 44079998 
tableread <- "vld_comext_monthly"
periodstart <- 201500
system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode %like% productpattern &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```

## Productcode as a character vector %like%
```{r}
productpattern <- "44079998"
tableread <- "vld_comext_monthly"
periodstart <- 201500
system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode %like% productpattern &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```


## Productcode as a character vector ==
```{r}
productpattern <- "44079998"
tableread <- "vld_comext_monthly"
periodstart <- 201500
system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode == productpattern &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```

## Productcode as a character vector %in%
```{r}
productpattern <- "44079998"
tableread <- "vld_comext_monthly"
periodstart <- 201500
system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode %in% productpattern &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```


# Cost of the addproreppar() function
The addproreppar() function add product description, reporter and partner to the querried data.
The 
### Productcode as a character vector %in% (several products) without codes
The explain shows "ALL" meaning that it will use a full table scan.
```{r}
swdcodes <- classificationimm$productcode[classificationimm$productimm=="Sawn: softwood"]
tableread <- "vld_comext_monthly"
periodstart <- 201500
remotequery <-  tbl(con, tableread) %>%
        filter(productcode %in% swdcodes & period > periodstart)
explain(remotequery)
system.time(dtf <- collect(remotequery))
```

### Productcode as a character vector %in% (several products) add prorepparcodes
```{r}
swdcodes <- classificationimm$productcode[classificationimm$productimm=="Sawn: softwood"]
tableread <- "vld_comext_monthly"
periodstart <- 201500

system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode %in% swdcodes &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```

### Product pattern %like% "pattern%" without product description, reporter and partner
```{r}
productpattern <- "440799%"
tableread <- "vld_comext_monthly"
periodstart <- 201500
system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode %like% productpattern &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```


### Product pattern %like% "pattern%" with product description, reporter and partner
```{r}
productpattern <- "440799%"
tableread <- "vld_comext_monthly"
periodstart <- 201500
system.time(dtf <- tbl(con, tableread) %>%
        filter(productcode %like% productpattern &
                   period > periodstart) %>% 
        addproreppar2tbl(con,.) %>% 
        collect())
```


